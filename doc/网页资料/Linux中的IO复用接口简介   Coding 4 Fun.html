<!DOCTYPE html>
<!-- saved from url=(0057)http://c4fun.cn/blog/2013/11/19/linux-io-reuse-interface/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  
  <title>Linux中的IO复用接口简介 | Coding 4 Fun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍了Linux中I/O复用接口的API,并对其进行对比,最后给出了相应程序。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux中的IO复用接口简介">
<meta property="og:url" content="http://c4fun.cn/blog/2013/11/19/linux-io-reuse-interface/index.html">
<meta property="og:site_name" content="Coding 4 Fun">
<meta property="og:description" content="介绍了Linux中I/O复用接口的API,并对其进行对比,最后给出了相应程序。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux中的IO复用接口简介">
<meta name="twitter:description" content="介绍了Linux中I/O复用接口的API,并对其进行对比,最后给出了相应程序。">
  
    <link rel="alternative" href="http://c4fun.cn/atom.xml" title="Coding 4 Fun" type="application/atom+xml">
  
  
    <link rel="icon" href="http://c4fun.cn/favicon.png">
  
  <link rel="stylesheet" href="./Linux中的IO复用接口简介   Coding 4 Fun_files/style.css" type="text/css">
  <link href="./Linux中的IO复用接口简介   Coding 4 Fun_files/css" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<!-- Google Analytics -->
<script async="" src="./Linux中的IO复用接口简介   Coding 4 Fun_files/analytics.js"></script><script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'c4fun.cn', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->

<script type="text/javascript" async="" src="./Linux中的IO复用接口简介   Coding 4 Fun_files/embed.js" charset="UTF-8"></script><script src="./Linux中的IO复用接口简介   Coding 4 Fun_files/share.js"></script><link type="text/css" rel="stylesheet" href="./Linux中的IO复用接口简介   Coding 4 Fun_files/embed.default.css"><link href="./Linux中的IO复用接口简介   Coding 4 Fun_files/bdshare.css" rel="styleSheet" type="text/css"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="http://c4fun.cn/" id="logo">Coding 4 Fun</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="http://c4fun.cn/" id="subtitle">Dream it, Believe it, Do IT!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="http://c4fun.cn/">Home</a>
        
          <a class="main-nav-link" href="http://c4fun.cn/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="http://c4fun.cn/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name="tn" type="hidden" value="bds">
          <input name="cl" type="hidden" value="3">
          <input name="ct" type="hidden" value="2097152">
          <input type="hidden" name="si" value="c4fun.cn">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-linux-io-reuse-interface" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="./Linux中的IO复用接口简介   Coding 4 Fun_files/Linux中的IO复用接口简介   Coding 4 Fun.html" class="article-date">
  <time datetime="2013-11-19T11:56:52.000Z" itemprop="datePublished">11月 19 2013</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="http://c4fun.cn/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux中的IO复用接口简介
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>﻿I/O复用是Linux中的I/O模型之一。所谓I/O复用，指的是进程预先告诉内核，使得内核一旦发现进程指定的一个或多个I/O条件就绪，就通知进程进行处理，从而不会在单个I/O上导致阻塞。  </p>
<p>在Linux中，提供了select、poll、epoll三类接口来实现I/O复用。</p>
<a id="more"></a>
<h2 id="select函数接口"><strong>select函数接口</strong></h2><p>select中主要就是一个select函数，用于监听指定事件的发生，原型如下:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/select.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;sys/time.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *rset, fd_set *wset, fd_set *eset, </span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">//返回:若有就绪描述符则返回其数目,超时返回0,出错返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中各参数的含义如下：<br><strong>maxfd</strong>：最大文件描述符加1，比它小的从0开始的描述符都将被监视，它的值不能超过系统中定义的FD_SETSIZE(通常是1024)。  </p>
<p><strong>rset,wset,eset</strong>：分别表示监视的读、写、错误的描述符位数组，通常是一个整数数组，每一个整数可以表示32个描述符是否被监视。需要注意的是这几个参数都是值-结果参数，在调用select后这几个参数将表示哪些描述符就绪了。通过以下几个宏可以很方便的操作fset数组:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</span><br><span class="line">	<span class="comment">//将一个fdset清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line">	<span class="comment">//将某个fd对应在该fd_set里的那一位打开</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line">	<span class="comment">//将某个fd对应在该fd_set里的那一位关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line">	<span class="comment">//检测某个fd_set里对应fd的那一位是否打开</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>timeout</strong>：超时时间，即select最长等待多久就返回，为NULL时表示等到有操作符准备就绪后才返回。该时间可以精确到微秒，其结构如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval{</span><br><span class="line">	<span class="keyword">long</span> tv_sec;<span class="comment">//秒数</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;<span class="comment">//微妙数	</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>描述符就绪条件<br>对于普通数据的读写，描述符就绪显而易见，但仍有一些特殊情况时描述符会读写就绪，UNP中对描述符的读写就绪条件进行了说明。  </p>
<p>1）满足以下4个条件时，描述符准备好读<br>a）套接字接收缓冲区中的数据字节数大于套接字接收缓冲区低水位标记的当前大小(默认为1)，读将会返回大于0的数。<br>b）该连接的读半部关闭，读将会返回0。<br>c）套接字上有一个错误待处理，读将返回-1。<br>d）该套接字是一个监听套接字并且已完成连接数不为0。  </p>
<p>2）满足以下4个条件时，描述符准备好写<br>a）套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小(默认2048)，写将会返回大于0的数。<br>b）该连接的写半部关闭，写将会返回EPIPE。<br>c）套接字上有一个错误待处理，写将返回-1。<br>d）使用非阻塞式connect的套接字建立有结果返回。  </p>
</blockquote>
<h2 id="poll函数接口"><strong>poll函数接口</strong></h2><p>poll中的主要函数也只有一个poll，与select作用类似，但参数有所不同，函数原型如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;poll.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//返回:若有就绪描述符则返回其数目,超时返回0,出错返回-1</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中各参数的含义如下：<br><strong>fdarray</strong>：是一个指向pollfd结构数组的指针，维护着描述符以及事件信息，该结构体是poll里比较核心的结构体，结构如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pollfd{</span><br><span class="line">	<span class="keyword">int</span> fd;			<span class="comment">//描述符</span></span><br><span class="line">	<span class="keyword">short</span> events;	<span class="comment">//关注的事件</span></span><br><span class="line">	<span class="keyword">short</span> revents;	<span class="comment">//发生的事件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该结构体通过两个变量区分关注的事件和发生的事件，从而避免了使用值-结果参数。events和revents可选的标志位如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">POLLIN			<span class="comment">//普通或优先级带数据可读</span></span><br><span class="line">POLLRDNORM		<span class="comment">//普通数据可读</span></span><br><span class="line">POLLRDBAND		<span class="comment">//优先级带数据可读</span></span><br><span class="line">POLLPRI			<span class="comment">//高优先级数据可读</span></span><br><span class="line">POLLOUT			<span class="comment">//普通数据可写</span></span><br><span class="line">POLLWRNORM		<span class="comment">//普通数据可写</span></span><br><span class="line">POLLWRBAND		<span class="comment">//优先级带数据可写</span></span><br><span class="line">POLLERR			<span class="comment">//发生错误</span></span><br><span class="line">POLLHUP			<span class="comment">//发生挂起</span></span><br><span class="line">POLLINVAL		<span class="comment">//描述符不是一个打开的文件</span></span><br><span class="line"><span class="comment">//其中POLLERR,POLLHUP,POLLINVAL仅作为reventes的标志位</span></span><br><span class="line"><span class="comment">//优先级带数据主要是指TCP的带外数据，其它大部分数据都是普通数据。</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>nfds</strong>：指定结构体数组中元素的个数。<br><strong>timeout</strong>：每次调用poll最大等待的毫秒数，负值代表等待到直到有事件触发。  </p>
<h2 id="epoll函数接口"><strong>epoll函数接口</strong></h2><p>epoll主要有三个函数，函数原型如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/epoll.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">	<span class="comment">//创建一个epoll句柄</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line">	<span class="comment">//注册一个epoll事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">	<span class="comment">//等待事件发生</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="epoll_create(int_size)"><strong>epoll_create(int size)</strong></h4><p><strong>size</strong>：能监听多少个描述符,返回一个epoll描述符。注意使用完epoll后要关闭该描述符。  </p>
<h4 id="epoll_ctl(int_efd,_int_op,_int_fd,_struct_epoll_event_*event)"><strong>epoll_ctl(int efd, int op, int fd, struct epoll_event *event)</strong></h4><p><strong>efd</strong>：epoll_create返回的epoll描述符<br><strong>op</strong>：表示动作，可以在以下三个宏里选择一个  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">EPOLL_CTL_ADD	<span class="comment">//注册新的fd到epoll中  </span></span><br><span class="line">EPOLL_CTL_MOD	<span class="comment">//修改已经注册的fd的监听事件  </span></span><br><span class="line">EPOLL_CTL_DEL	<span class="comment">//从epoll中删除一个fd</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>fd</strong>：要监听的fd<br><strong>event</strong>：告诉内核要监听什么事件，其结构如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data {</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	__uint32_t u32;</span><br><span class="line">	__uint64_t u64;</span><br><span class="line">} epoll_data_t;</span><br><span class="line"><span class="keyword">struct</span> epoll_event {</span><br><span class="line">	__uint32_t events; 	<span class="comment">//epoll事件</span></span><br><span class="line">	epoll_data_t data; 	<span class="comment">//用于储存epoll描述符信息</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>其中events表示epoll事件，可选的标志位如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">EPOLLIN		<span class="comment">//描述符可以读</span></span><br><span class="line">EPOLLOUT 	<span class="comment">//描述符可以写</span></span><br><span class="line">EPOLLPRI    <span class="comment">//描述符有优先数据可读（带外数据）</span></span><br><span class="line">EPOLLERR    <span class="comment">//文件描述符发生错误；</span></span><br><span class="line">EPOLLHUP    <span class="comment">//文件描述符被挂断；</span></span><br><span class="line">EPOLLET     <span class="comment">//将EPOLL设为边缘触发(Edge Triggered)模式，默认是水平触发(Level Triggered)。</span></span><br><span class="line">EPOLLRDHUP	<span class="comment">//对端关闭连接</span></span><br><span class="line">EPOLLONESHOT<span class="comment">//只监听一次事件，事件发生后该描述符的其他信息将不被提示。</span></span><br></pre></td></tr></tbody></table></figure>
<p>而epoll_data_t使用了union来存储数据，用户可以使用data来存放一些关于该fd的额外内容。  </p>
<blockquote>
<p>标志位中比较特殊的是EPOLLET这个选项，这个选项将EPOLL设置为边缘触发模式，EPOLL有EPOLLET和EPOLLLT两种工作模式。<br><strong>EPOLLLT(Level Triggered,水平触发模式)</strong>：默认工作模式，支持block和no-block socket，内核通知你描述符事件后，如果不进行操作，会一直通知。<br><strong>EPOLLET(Edge Triggered,边缘触发模式)</strong>：高速工作模式，只支持no-block socket，只会在描述符状态由未就绪转为就绪时会通知一次，使用该模式时，如果程序编写的不够健全，是很容易出现问题的。  </p>
</blockquote>
<h4 id="epoll_wait(int_efd,_struct_epoll_event_*events,_int_maxevents,_int_timeout);"><strong>epoll_wait(int efd, struct epoll_event *events, int maxevents, int timeout);</strong></h4><p>该函数与select和poll函数的功能类似，监视指定事件的发生并返回给用户。<br><strong>efd</strong>：epoll_create返回的opoll描述符。<br><strong>events</strong>：用来从内核得到事件的集合。<br><strong>maxevents</strong>：用来告知内核events数组的大小。<br><strong>timeout</strong>：超时时间，-1将阻塞直到有事件发生，否则表示最多等待多少毫秒后函数就返回。</p>
<h2 id="select,poll,epoll比较"><strong>select,poll,epoll比较</strong></h2><h3 id="select"><strong>select</strong></h3><ul>
<li>select能监控的描述符个数由内核中的FD_SETSIZE限制，仅为1024，这也是select最大的缺点，因为现在的服务器并发量远远不止1024。即使能重新编译内核改变FD_SETSIZE的值，但这并不能提高select的性能。</li>
<li>每次调用select都会线性扫描所有描述符的状态，在select结束后，用户也要线性扫描fd_set数组才知道哪些描述符准备就绪，等于说每次调用复杂度都是O（n）的，在并发量大的情况下，每次扫描都是相当耗时的，很有可能有未处理的连接等待超时。</li>
<li>每次调用select都要在用户空间和内核空间里进行内存复制fd描述符等信息。</li>
</ul>
<h3 id="poll"><strong>poll</strong></h3><ul>
<li>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制。</li>
<li>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服务器性能会快速下降。</li>
</ul>
<h3 id="epoll"><strong>epoll</strong></h3><ul>
<li>epoll维护的描述符数目不受到限制，而且性能不会随着描述符数目的增加而下降。</li>
<li>服务器的特点是经常维护着大量连接，但其中某一时刻读写的操作符数量却不多。epoll先通过epoll_ctl注册一个描述符到内核中，并一直维护着而不像poll每次操作都将所有要监控的描述符传递给内核；在描述符读写就绪时，通过回掉函数将自己加入就绪队列中，之后epoll_wait返回该就绪队列。也就是说，epoll基本不做无用的操作，时间复杂度仅与活跃的客户端数有关，而不会随着描述符数目的增加而下降。</li>
<li>epoll在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝，这也使得epoll的效率比poll和select更高。</li>
</ul>
<h2 id="程序示例"><strong>程序示例</strong></h2><p>分别使用select，poll和epoll实现了简单的回显服务器程序，客户端使用select来实现。其中select和poll程序主要参考unp的实现，只是Demo程序，对一些异常情况没有进行处理。</p>
<h3 id="客户端程序"><strong>客户端程序</strong></h3><p>使用select来监听终端输入和连接服务器的流输入，这样可以保证客户端不在某一个输入流上死等。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line">in_port_t SERV_PORT = <span class="number">8888</span>;</span><br><span class="line"><span class="comment">//char *addr = "192.168.0.231";</span></span><br><span class="line"><span class="keyword">char</span> *addr = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in servaddr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, addr, &amp;servaddr.sin_addr);</span><br><span class="line">	</span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	connect(sockfd, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line"></span><br><span class="line">	str_cli(stdin, sockfd);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_cli</span><span class="params">(FILE *fp, <span class="keyword">int</span> sockfd)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> maxfd, stdineof, n;</span><br><span class="line">	fd_set rset;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	stdineof = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		<span class="comment">//如果不是已经输入结束,就继续监听终端输入</span></span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span>) FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		<span class="comment">//监听来自服务器的信息</span></span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		<span class="comment">//maxfd设置为sockfd和stdin中较大的一个加1</span></span><br><span class="line">		maxfd = (fileno(fp) &gt; sockfd ? fileno(fp) : sockfd) + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//只关心是否有描述符读就绪,其他几个直接传NULL即可</span></span><br><span class="line">		select(maxfd, &amp;rset, NULL, NULL, NULL);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果有来自服务器的信息可读</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) {</span><br><span class="line">			<span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) == <span class="number">0</span>) {</span><br><span class="line">				<span class="comment">//如果这边输入了EOF之后服务器close掉连接说明正常结束，否则为异常结束</span></span><br><span class="line">				<span class="keyword">if</span> (stdineof == <span class="number">1</span>) </span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					perror(<span class="string">"terminated error\n"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//输出到终端</span></span><br><span class="line">			write(fileno(stdout), buf, n);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//如果有来自终端的输入</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) {</span><br><span class="line">			<span class="comment">//终端这边输入了结束符</span></span><br><span class="line">			<span class="keyword">if</span> ((n = read(fileno(fp), buf, MAXLINE)) == <span class="number">0</span>) {</span><br><span class="line">				<span class="comment">//标记已经输入完毕，并只单端关闭写，因为可能还有消息在来客户端的路上尚未处理</span></span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				shutdown(sockfd, SHUT_WR);</span><br><span class="line">				<span class="comment">//不再监听终端输入</span></span><br><span class="line">				FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//将输入信息发送给服务器</span></span><br><span class="line">			write(sockfd, buf, n);	</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="select服务器"><strong>select服务器</strong></h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line">in_port_t SERV_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argv[])</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> maxfd, maxi, nready, client[FD_SETSIZE];</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in cliaddr, servaddr;</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">	ssize_t n;</span><br><span class="line">	fd_set rset, allset;</span><br><span class="line"></span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (-<span class="number">1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> servaddr))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"bind error\n"</span>);</span><br><span class="line">	</span><br><span class="line">	listen(listenfd, <span class="number">1024</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//客户端描述符存储在client中,maxi表示该数组最大的存有客户端描述符的数组下标</span></span><br><span class="line">	maxfd = listenfd;</span><br><span class="line">	maxi = -<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(client, -<span class="number">1</span>, <span class="keyword">sizeof</span> client);</span><br><span class="line">	<span class="comment">//初始化读就绪的fd_set数组，并监听listen描述符</span></span><br><span class="line">	FD_ZERO(&amp;allset);</span><br><span class="line">	FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		<span class="comment">//allset是监控的描述符列表，rset是可读描述符列表</span></span><br><span class="line">		rset = allset;</span><br><span class="line">		nready = select(maxfd+<span class="number">1</span>, &amp;rset, NULL, NULL, NULL);</span><br><span class="line">		<span class="comment">//如果listen描述符可读，说明有客户端连接</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) {</span><br><span class="line">			clilen = <span class="keyword">sizeof</span> cliaddr;</span><br><span class="line">			connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="keyword">if</span> (connfd == -<span class="number">1</span>) perror(<span class="string">"accept error\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d accepted!\n"</span>, connfd);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//扫描client数组，找到下标最小的未用的来存客户端描述符</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++) <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) {</span><br><span class="line">				client[i] = connfd;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (i == FD_SETSIZE) perror(<span class="string">"too many clients\n"</span>);</span><br><span class="line">			<span class="comment">//将客户端描述符放到监视的fd_set中，并更新maxfd和maxi</span></span><br><span class="line">			FD_SET(connfd, &amp;allset);</span><br><span class="line">			<span class="keyword">if</span> (connfd &gt; maxfd) maxfd = connfd;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi) maxi = i;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//扫描所有的客户端，查看是否有描述符读就绪</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) {</span><br><span class="line">			<span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) {</span><br><span class="line">				<span class="comment">//读到EOF或错误,清除该描述符</span></span><br><span class="line">				<span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt;= <span class="number">0</span>) {</span><br><span class="line">					close(sockfd);</span><br><span class="line">					FD_CLR(sockfd, &amp;allset);</span><br><span class="line">					client[i] = -<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (n &lt; <span class="number">0</span>) perror(<span class="string">"read error\n"</span>);</span><br><span class="line">				<span class="comment">//回显给客户端</span></span><br><span class="line">				} <span class="keyword">else</span> {</span><br><span class="line">					write(sockfd, buf, n);</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="poll服务器"><strong>poll服务器</strong></h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/select.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;limits.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;poll.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef OPEN_MAX</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">in_port_t SERV_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> *argv[])</span></span>{</span><br><span class="line">	<span class="keyword">int</span> i, maxi;</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd, sockfd;</span><br><span class="line">	<span class="keyword">int</span> nready;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="keyword">struct</span> pollfd client[OPEN_MAX];</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in cliaddr, servaddr;</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">	ssize_t n;</span><br><span class="line">	</span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (-<span class="number">1</span> == bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> servaddr))</span><br><span class="line">		perror(<span class="string">"bind error\n"</span>);</span><br><span class="line">	</span><br><span class="line">	listen(listenfd, <span class="number">1024</span>);</span><br><span class="line">	<span class="comment">//client保存了pull监听的描述符，其中client[0]是给listen描述符的</span></span><br><span class="line">	client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i].fd = -<span class="number">1</span>;</span><br><span class="line">	maxi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		nready = poll(client, maxi+<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//如果是监听描述符可读,说明有客户端连入</span></span><br><span class="line">		<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) {</span><br><span class="line">			clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="keyword">if</span> (connfd == -<span class="number">1</span>) perror(<span class="string">"accept error\n"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d accepted!\n"</span>, connfd);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//扫描clien数组，找到下标最小的未用的来存客户端描述符</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) {</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) {</span><br><span class="line">					client[i].fd = connfd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX) perror(<span class="string">"too many clients.\n"</span>);</span><br><span class="line">			client[i].events = POLLRDNORM;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi) maxi = i;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//扫描所有的客户端描述符</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) {</span><br><span class="line">			<span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//POLLERR不需要监听，如果有错误的话poll返回时会自动加上</span></span><br><span class="line">			<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) {</span><br><span class="line">				<span class="comment">//读到EOF或错误关闭描述符</span></span><br><span class="line">				<span class="keyword">if</span> ((n = read(sockfd, buf, MAXLINE)) &lt;= <span class="number">0</span>) {</span><br><span class="line">					close(sockfd);</span><br><span class="line">					client[i].fd = -<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (n &lt; <span class="number">0</span>) perror(<span class="string">"read error\n"</span>);</span><br><span class="line">				<span class="comment">//回显给客户端</span></span><br><span class="line">				} <span class="keyword">else</span> {</span><br><span class="line">					write(sockfd, buf, n);</span><br><span class="line">				}</span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="epoll服务器"><strong>epoll服务器</strong></h3><p>回显服务器使用了ET高速模式。在该模式下，最好所有的操作都是非阻塞的，程序中套接字都设置为了non-socket，并且使用了缓冲区，在读到数据时先将数据存到缓冲区中，下次可写时才将数据从缓冲区写回客户端。<br>另外，在ET模式下，accept、read、write时都要使用循环直到读到EAGAIN才能说明没有数据了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/epoll.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;errno.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fcntl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef OPEN_MAX</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> OPEN_MAX 1024</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SERV_PORT 8888</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> EVENT_MAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> event_data{</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">int</span> offset;</span><br><span class="line">	<span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">}event_d[OPEN_MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_event_d</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *evt, <span class="keyword">struct</span> event_data *met)</span></span>{</span><br><span class="line">	met-&gt;fd = fd;</span><br><span class="line">	met-&gt;offset = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;met-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span> met-&gt;buf);</span><br><span class="line">	evt-&gt;data.ptr = met;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>{</span><br><span class="line">	<span class="keyword">int</span> listenfd, connfd, epfd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in servaddr, cliaddr;</span><br><span class="line">    <span class="keyword">int</span> i, j, nready;</span><br><span class="line">	socklen_t clilen;</span><br><span class="line">    ssize_t n, wpos;</span><br><span class="line">    <span class="keyword">struct</span> epoll_event evt, evts[EVENT_MAX];</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置lisenfd非阻塞</span></span><br><span class="line">	fcntl(listenfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> servaddr);</span><br><span class="line">    listen(listenfd, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建epoll描述符</span></span><br><span class="line">    epfd = epoll_create(OPEN_MAX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将listen描述符加入到epoll中</span></span><br><span class="line">	set_event_d(listenfd, &amp;evt, &amp;event_d[<span class="number">0</span>]);</span><br><span class="line">	evt.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;evt);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//event_d中的fd为-1表示没有使用，0用来存listenfd，其它用来存客户端fd</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) event_d[i].fd = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">	    nready = epoll_wait(epfd, evts, EVENT_MAX, -<span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) {</span><br><span class="line">			<span class="comment">//读取存储描述符信息的指针</span></span><br><span class="line">			<span class="keyword">struct</span> event_data *ed = (<span class="keyword">struct</span> event_data*)evts[i].data.ptr;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//accept</span></span><br><span class="line">            <span class="keyword">if</span> (ed-&gt;fd == listenfd) {</span><br><span class="line">            	<span class="comment">//ET模式下存在多个client connect只通知一次的情况,需要循环accept直到读到EAGAIN</span></span><br><span class="line">				<span class="keyword">for</span>(;;) {</span><br><span class="line">					clilen = <span class="keyword">sizeof</span> cliaddr;</span><br><span class="line">					connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">					<span class="keyword">if</span> (connfd == -<span class="number">1</span>) {</span><br><span class="line">						<span class="keyword">if</span> (errno == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">else</span> perror(<span class="string">"accept error"</span>);</span><br><span class="line">					} <span class="keyword">else</span> {</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"a client connected! fd: %d\n"</span>, connfd);</span><br><span class="line">					}</span><br><span class="line">					<span class="comment">//找到可用的event_d来存放event.data</span></span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; OPEN_MAX; j++) {</span><br><span class="line">						<span class="keyword">if</span> (event_d[j].fd == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span> (j == OPEN_MAX) {</span><br><span class="line">						perror(<span class="string">"too many clients"</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">					<span class="comment">//设置客户端fd非阻塞</span></span><br><span class="line">					fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">					set_event_d(connfd, &amp;evt, &amp;event_d[j]);</span><br><span class="line">					evt.events = EPOLLIN | EPOLLET;</span><br><span class="line">					epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;evt);</span><br><span class="line">				}</span><br><span class="line">			<span class="comment">//read</span></span><br><span class="line">			} <span class="keyword">else</span> <span class="keyword">if</span>(evts[i].events &amp; EPOLLIN){</span><br><span class="line">				<span class="comment">//ET模式，重复读直到EAGAIN说明无数据可读或者读到错误及EOF</span></span><br><span class="line">				<span class="keyword">for</span> (;ed-&gt;offset &lt; MAXLINE;) {</span><br><span class="line">					n = read(ed-&gt;fd, ed-&gt;buf + ed-&gt;offset, MAXLINE - ed-&gt;offset);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {</span><br><span class="line">						<span class="keyword">if</span> (errno == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">						close(ed-&gt;fd);</span><br><span class="line">						ed-&gt;fd = -<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">					ed-&gt;offset += n;</span><br><span class="line">				}</span><br><span class="line">				<span class="comment">//修改为监听描述符写就绪</span></span><br><span class="line">				evt.events = EPOLLOUT | EPOLLET;</span><br><span class="line">				evt.data.ptr = ed;</span><br><span class="line">				epoll_ctl(epfd, EPOLL_CTL_MOD, ed-&gt;fd, &amp;evt);</span><br><span class="line">			<span class="comment">//write</span></span><br><span class="line">			} <span class="keyword">else</span> <span class="keyword">if</span>(evts[i].events &amp; EPOLLOUT){</span><br><span class="line">				wpos = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">//ET模式下，重复写直到无数据可发或者EAGAIN</span></span><br><span class="line">				<span class="keyword">for</span> (;wpos &lt; ed-&gt;offset;) {</span><br><span class="line">					n = write(ed-&gt;fd, ed-&gt;buf + wpos, ed-&gt;offset - wpos);</span><br><span class="line">					<span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">						<span class="keyword">if</span> (errno == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">						<span class="keyword">if</span> (errno == EINTR) <span class="keyword">continue</span>;</span><br><span class="line">						close(ed-&gt;fd);</span><br><span class="line">						ed-&gt;fd = -<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					}</span><br><span class="line">					wpos += n;</span><br><span class="line">				}</span><br><span class="line">				ed-&gt;offset = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">//修改为监听描述符读就绪</span></span><br><span class="line">				evt.events = EPOLLIN | EPOLLET;</span><br><span class="line">				evt.data.ptr = ed;</span><br><span class="line">				epoll_ctl(epfd, EPOLL_CTL_MOD, ed-&gt;fd, &amp;evt);</span><br><span class="line">			}</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://c4fun.cn/blog/2013/11/19/linux-io-reuse-interface/" data-id="cig4osv1z00513aawc9ap89xf" class="article-share-link" data-share="baidu" data-title="Linux中的IO复用接口简介">分享到</a>
      

      
        <a href="http://c4fun.cn/blog/2013/11/19/linux-io-reuse-interface/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="http://c4fun.cn/tags/I-O%E5%A4%8D%E7%94%A8/">I/O复用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="http://c4fun.cn/tags/epoll/">epoll</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="http://c4fun.cn/blog/2013/11/21/binary-tree-nonrecursive-traversal/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          另一种二叉树非递归遍历的实现
        
      </div>
    </a>
  
  
    <a href="http://c4fun.cn/blog/2013/11/19/linux-ap-by-madwifi/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Linux下使用无线网卡搭建AP</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="blog/2013/11/19/linux-io-reuse-interface/" data-title="Linux中的IO复用接口简介" data-url="http://c4fun.cn/blog/2013/11/19/linux-io-reuse-interface/"><div id="ds-reset"><div class="ds-meta" style="display: none;"><a href="javascript:void(0)" class="ds-like-thread-button ds-rounded"><span class="ds-icon ds-icon-heart"></span> <span class="ds-thread-like-text">喜欢</span><span class="ds-thread-cancel-like">取消喜欢</span></a><span class="ds-like-panel"></span></div><div class="ds-comments-info"><div class="ds-sort"><a class="ds-order-desc">最新</a><a class="ds-order-asc ds-current">最早</a><a class="ds-order-hot">最热</a></div><ul class="ds-comments-tabs"><li class="ds-tab"><a class="ds-comments-tab-duoshuo ds-current" href="javascript:void(0);">0条评论</a></li>  </ul></div><ul class="ds-comments"><li class="ds-post ds-post-placeholder">还没有评论，沙发等你来抢</li></ul><div class="ds-paginator" style="display: none;"><div class="ds-border"></div><a data-page="1" href="javascript:void(0);" class="ds-current">1</a></div><a name="respond"></a><div class="ds-login-buttons"><p>社交帐号登录:</p><div class="ds-social-links"><ul class="ds-service-list"><li><a href="http://c4fun.duoshuo.com/login/weibo/" rel="nofollow" class="ds-service-link ds-weibo">微博</a></li><li><a href="http://c4fun.duoshuo.com/login/qq/" rel="nofollow" class="ds-service-link ds-qq">QQ</a></li><li><a href="http://c4fun.duoshuo.com/login/renren/" rel="nofollow" class="ds-service-link ds-renren">人人</a></li><li><a href="http://c4fun.duoshuo.com/login/douban/" rel="nofollow" class="ds-service-link ds-douban">豆瓣</a></li><li><a class="ds-more-services" href="javascript:void(0)">更多»</a></li></ul><ul class="ds-service-list ds-additional-services"><li><a href="http://c4fun.duoshuo.com/login/kaixin/" rel="nofollow" class="ds-service-link ds-kaixin">开心</a></li><li><a href="http://c4fun.duoshuo.com/login/netease/" rel="nofollow" class="ds-service-link ds-netease">网易</a></li><li><a href="http://c4fun.duoshuo.com/login/sohu/" rel="nofollow" class="ds-service-link ds-sohu">搜狐</a></li><li><a href="http://c4fun.duoshuo.com/login/baidu/" rel="nofollow" class="ds-service-link ds-baidu">百度</a></li><li><a href="http://c4fun.duoshuo.com/login/google/" rel="nofollow" class="ds-service-link ds-google">谷歌</a></li></ul></div></div><div class="ds-replybox"><a class="ds-avatar" href="javascript:void(0);" onclick="return false"><img src="./Linux中的IO复用接口简介   Coding 4 Fun_files/noavatar_default.png" alt=""></a><form method="post"><input type="hidden" name="thread_id" value="6206157747638534913">
<input type="hidden" name="parent_id" value="">
<input type="hidden" name="nonce" value="5634e4712ada9"><div class="ds-textarea-wrapper ds-rounded-top"><textarea name="message" title="Ctrl+Enter快捷提交" placeholder="说点什么吧…"></textarea><pre class="ds-hidden-text"></pre></div><div class="ds-post-toolbar"><div class="ds-post-options ds-gradient-bg"><span class="ds-sync"></span></div><button class="ds-post-button" type="submit">发布</button><div class="ds-toolbar-buttons"><a class="ds-toolbar-button ds-add-emote" title="插入表情"></a></div></div></form></div><p class="ds-powered-by"><a href="http://duoshuo.com/" target="_blank" rel="nofollow">Powered by 多说</a></p></div></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Algorithm/">Algorithm</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Blog/">Blog</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/C-C/">C/C++</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Linux/">Linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/MAC/">MAC</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/OpenGL-D3D/">OpenGL&amp;D3D</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Tips/">Tips</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/Tools/">Tools</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="http://c4fun.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">环境搭建</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://c4fun.cn/blog/2015/10/03/osx-xcode-opengl/">在OSX中进行OpenGL开发</a>
          </li>
        
          <li>
            <a href="http://c4fun.cn/blog/2015/06/23/xcode64-alactraz-bug/">Xcode6.4中Alcatraz无法启动</a>
          </li>
        
          <li>
            <a href="http://c4fun.cn/blog/2015/06/23/vim-base-operation/">Vim基础操作汇总</a>
          </li>
        
          <li>
            <a href="http://c4fun.cn/blog/2015/06/13/apache-reverse-proxy/">通过Apache反向代理访问本地Gogs服务</a>
          </li>
        
          <li>
            <a href="http://c4fun.cn/blog/2015/06/09/mac-another-screen/">Macbook修改外接显示器分辨率</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="http://c4fun.cn/tags/AP/" style="font-size: 10px;">AP</a><a href="http://c4fun.cn/tags/Alcatraz/" style="font-size: 10px;">Alcatraz</a><a href="http://c4fun.cn/tags/Algorithm/" style="font-size: 17.5px;">Algorithm</a><a href="http://c4fun.cn/tags/Apache/" style="font-size: 10px;">Apache</a><a href="http://c4fun.cn/tags/C/" style="font-size: 15px;">C</a><a href="http://c4fun.cn/tags/Cmockery/" style="font-size: 10px;">Cmockery</a><a href="http://c4fun.cn/tags/Hexo/" style="font-size: 10px;">Hexo</a><a href="http://c4fun.cn/tags/I-O%E5%A4%8D%E7%94%A8/" style="font-size: 10px;">I/O复用</a><a href="http://c4fun.cn/tags/Leetcode-OJ/" style="font-size: 15px;">Leetcode OJ</a><a href="http://c4fun.cn/tags/Libev/" style="font-size: 10px;">Libev</a><a href="http://c4fun.cn/tags/Linux/" style="font-size: 20px;">Linux</a><a href="http://c4fun.cn/tags/MAC/" style="font-size: 10px;">MAC</a><a href="http://c4fun.cn/tags/Makefile/" style="font-size: 15px;">Makefile</a><a href="http://c4fun.cn/tags/Maven/" style="font-size: 10px;">Maven</a><a href="http://c4fun.cn/tags/OSX/" style="font-size: 10px;">OSX</a><a href="http://c4fun.cn/tags/Octopress/" style="font-size: 12.5px;">Octopress</a><a href="http://c4fun.cn/tags/OpenGL/" style="font-size: 10px;">OpenGL</a><a href="http://c4fun.cn/tags/Proxy/" style="font-size: 10px;">Proxy</a><a href="http://c4fun.cn/tags/Python/" style="font-size: 15px;">Python</a><a href="http://c4fun.cn/tags/Sublime-text3/" style="font-size: 10px;">Sublime text3</a><a href="http://c4fun.cn/tags/Tools/" style="font-size: 10px;">Tools</a><a href="http://c4fun.cn/tags/Vim/" style="font-size: 10px;">Vim</a><a href="http://c4fun.cn/tags/Xcode/" style="font-size: 10px;">Xcode</a><a href="http://c4fun.cn/tags/epoll/" style="font-size: 10px;">epoll</a><a href="http://c4fun.cn/tags/iconv/" style="font-size: 10px;">iconv</a><a href="http://c4fun.cn/tags/madwifi/" style="font-size: 12.5px;">madwifi</a><a href="http://c4fun.cn/tags/wlanconfig/" style="font-size: 10px;">wlanconfig</a><a href="http://c4fun.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a><a href="http://c4fun.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">单元测试</a><a href="http://c4fun.cn/tags/%E5%A0%86/" style="font-size: 10px;">堆</a><a href="http://c4fun.cn/tags/%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/" style="font-size: 10px;">外接显示器</a><a href="http://c4fun.cn/tags/%E5%A4%A9%E5%A4%A9%E7%88%B1%E6%B6%88%E9%99%A4/" style="font-size: 10px;">天天爱消除</a><a href="http://c4fun.cn/tags/%E5%AE%8F/" style="font-size: 10px;">宏</a><a href="http://c4fun.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a><a href="http://c4fun.cn/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" style="font-size: 10px;">线程同步</a><a href="http://c4fun.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/" style="font-size: 10px;">结构体</a><a href="http://c4fun.cn/tags/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" style="font-size: 12.5px;">驱动程序</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2015/06/">六月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2014/12/">十二月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2014/10/">十月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2014/05/">五月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2014/03/">三月 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2014/01/">一月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://c4fun.cn/archives/2013/11/">十一月 2013</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/swm8023" target="_blank">swm8023@github</a>
          </li>
        
          <li>
            <a href="http://blog.csdn.net/swm8023" target="_blank">swm8023@csdn</a>
          </li>
        
          <li>
            <a href="http://www.cnblogs.com/swm8023/" target="_blank">swm8023@cnblogs</a>
          </li>
        
          <li>
            <a href="http://www.cnblogs.com/CSGrandeur/" target="_blank">CSGrandeur</a>
          </li>
        
          <li>
            <a href="http://hujiaweibujidao.github.io/" target="_blank">Hujiawei Bujidao</a>
          </li>
        
          <li>
            <a href="http://blog.chinaunix.net/uid/28387257.html" target="_blank">Henrystark's CU blog</a>
          </li>
        
          <li>
            <a href="http://oxoo.org/" target="_blank">OxOo社</a>
          </li>
        
          <li>
            <a href="http://www.cnblogs.com/staginner/" target="_blank">Staginner</a>
          </li>
        
          <li>
            <a href="http://zhangxc.com/" target="_blank">张学程</a>
          </li>
        
          <li>
            <a href="http://yangha.github.io/" target="_blank">小阳Space</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      © 2015 swm8023<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="http://c4fun.cn/" class="mobile-nav-link">Home</a>
  
    <a href="http://c4fun.cn/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop" style="opacity: 1; display: block;">
<a title="返回顶部"><img src="./Linux中的IO复用接口简介   Coding 4 Fun_files/scrollup.png"></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"c4fun"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links bdshare-button-style0-16" data-bd-bind="1446306930719">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="./Linux中的IO复用接口简介   Coding 4 Fun_files/jquery.min.js"></script>




<script src="./Linux中的IO复用接口简介   Coding 4 Fun_files/script.js" type="text/javascript"></script>

</div>


</body></html>